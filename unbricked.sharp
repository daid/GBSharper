; https://raw.githubusercontent.com/gbdev/gb-asm-tutorial/master/unbricked/bricks/main.asm
; INCLUDE "hardware.inc"
reg rLCDC = 0xFF40
reg rLY = 0xFF44
reg rBGP = 0xFF47
reg rOBP0 = 0xFF48
reg _OAMRAM0 = 0xFE00
reg _OAMRAM1 = 0xFE01
reg _OAMRAM2 = 0xFE02
reg _OAMRAM3 = 0xFE03
reg _OAMRAM4 = 0xFE04
reg _OAMRAM5 = 0xFE05
reg _OAMRAM6 = 0xFE06
reg _OAMRAM7 = 0xFE07


const BRICK_LEFT = 0x05
const BRICK_RIGHT = 0x06
const BLANK_TILE = 0x08

var frameCounter = 0

var curKeys = 0
var newKeys = 0

var ballMomentumX = 0
var ballMomentumY = 0

fn main
    while rLY < 144
        pass
    rLCDC = 0

    ; Copy the tile data
;    ld de, Tiles
;    ld hl, $9000
;    ld bc, TilesEnd - Tiles
;    call Memcopy

    ; Copy the tilemap
;    ld de, Tilemap
;    ld hl, $9800
;    ld bc, TilemapEnd - Tilemap
;    call Memcopy

    ; Copy the paddle tile
;    ld de, Paddle
;    ld hl, $8000
;    ld bc, PaddleEnd - Paddle
;    call Memcopy

    ; Copy the ball tile
;    ld de, Ball
;    ld hl, $8010
;    ld bc, BallEnd - Ball
;    call Memcopy

;    xor a, a
;    ld b, 160
;    ld hl, _OAMRAM
;ClearOam:
;    ld [hli], a
;    dec b
;    jp nz, ClearOam

    ; Initialize the paddle sprite in OAM
    _OAMRAM0 = 128 + 16
    _OAMRAM1 = 16 + 8
    _OAMRAM2 = 0
    _OAMRAM3 = 0
    ; Now initialize the ball sprite
    _OAMRAM4 = 100 + 16
    _OAMRAM5 = 32 + 8
    _OAMRAM6 = 1
    _OAMRAM7 = 0

    ; The ball starts out going up and to the right
    ballMomentumX = 1
    ballMomentumY = -1

    ; Turn the LCD on
    rLCDC = 0x83 ; LCDCF_ON | LCDCF_BGON | LCDCF_OBJON

    ; During the first (blank) frame, initialize display registers
    rBGP = 0b11100100
    rOBP0 = 0b11100100

    ; Initialize global variables
    frameCounter = 0
    curKeys = 0
    newKeys = 0

    while 1
        while rLY > 143
            pass
        while rLY < 144
            pass

        ; Add the ball's momentum to its position in OAM.
        _OAMRAM5 = _OAMRAM5 + ballMomentumX
        _OAMRAM4 = _OAMRAM4 + ballMomentumY

    ; ANCHOR: updated-bounce
    ;BounceOnTop:
    ;    ; Remember to offset the OAM position!
    ;    ; (8, 16) in OAM coordinates is (0, 0) on the screen.
    ;    ld a, [_OAMRAM + 4]
    ;    sub a, 16 + 1
    ;    ld c, a
    ;    ld a, [_OAMRAM + 5]
    ;    sub a, 8
    ;    ld b, a
    ;    call GetTileByPixel ; Returns tile address in hl
    ;    ld a, [hl]
    ;    call IsWallTile
    ;    jp nz, BounceOnRight
    ;    call CheckAndHandleBrick
    ;    ld a, 1
    ;    ld [wBallMomentumY], a
    
    ;BounceOnRight:
    ;    ld a, [_OAMRAM + 4]
    ;    sub a, 16
    ;    ld c, a
    ;    ld a, [_OAMRAM + 5]
    ;    sub a, 8 - 1
    ;    ld b, a
    ;    call GetTileByPixel
    ;    ld a, [hl]
    ;    call IsWallTile
    ;    jp nz, BounceOnLeft
    ;    call CheckAndHandleBrick
    ;    ld a, -1
    ;    ld [wBallMomentumX], a
    ;
    ;BounceOnLeft:
    ;    ld a, [_OAMRAM + 4]
    ;    sub a, 16
    ;    ld c, a
    ;    ld a, [_OAMRAM + 5]
    ;    sub a, 8 + 1
    ;    ld b, a
    ;    call GetTileByPixel
    ;    ld a, [hl]
    ;    call IsWallTile
    ;    jp nz, BounceOnBottom
    ;    call CheckAndHandleBrick
    ;    ld a, 1
    ;    ld [wBallMomentumX], a

    ;BounceOnBottom:
    ;    ld a, [_OAMRAM + 4]
    ;    sub a, 16 - 1
    ;    ld c, a
    ;    ld a, [_OAMRAM + 5]
    ;    sub a, 8
    ;    ld b, a
    ;    call GetTileByPixel
    ;    ld a, [hl]
    ;    call IsWallTile
    ;    jp nz, BounceDone
    ;    call CheckAndHandleBrick
    ;    ld a, -1
    ;    ld [wBallMomentumY], a
    ;BounceDone:
    ; ANCHOR_END: updated-bounce

        ; First, check if the ball is low enough to bounce off the paddle.
        if _OAMRAM0 == _OAMRAM4
            ; Now let's compare the X positions of the objects to see if they're touching.
            if _OAMRAM5 < _OAMRAM1 + 16
                if _OAMRAM5 > _OAMRAM1 - 8
                    ballMomentumY = -1

        ; Check the current keys every frame and move left or right.
        Input()

    ;    ; First, check if the left button is pressed.
    ;CheckLeft:
    ;    ld a, [wCurKeys]
    ;    and a, PADF_LEFT
    ;    jp z, CheckRight
    ;Left:
    ;    ; Move the paddle one pixel to the left.
    ;    ld a, [_OAMRAM + 1]
    ;    dec a
    ;    ; If we've already hit the edge of the playfield, don't move.
    ;    cp a, 15
    ;    jp z, Main
    ;    ld [_OAMRAM + 1], a
    ;    jp Main

;; Then check the right button.
;CheckRight:
;    ld a, [wCurKeys]
;    and a, PADF_RIGHT
;    jp z, Main
;Right:
;    ; Move the paddle one pixel to the right.
;    ld a, [_OAMRAM + 1]
;    inc a
;    ; If we've already hit the edge of the playfield, don't move.
;    cp a, 105
;    jp z, Main
;    ld [_OAMRAM + 1], a
;    jp Main
;
;; Convert a pixel position to a tilemap address
;; hl = $9800 + X + Y * 32
;; @param b: X
;; @param c: Y
;; @return hl: tile address
;GetTileByPixel:
;    ; First, we need to divide by 8 to convert a pixel position to a tile position.
;    ; After this we want to multiply the Y position by 32.
;    ; These operations effectively cancel out so we only need to mask the Y value.
;    ld a, c
;    and a, %11111000
;    ld l, a
;    ld h, 0
;    ; Now we have the position * 8 in hl
;    add hl, hl ; position * 16
;    add hl, hl ; position * 32
;    ; Just add the X position and offset to the tilemap, and we're done.
;    ld a, b
;    srl a ; a / 2
;    srl a ; a / 4
;    srl a ; a / 8
;    add a, l
;    ld l, a
;    adc a, h
;    sub a, l
;    ld h, a
;    ld bc, $9800
;    add hl, bc
;    ret
;
;; @param a: tile ID
;; @return z: set if a is a wall.
;IsWallTile:
;    cp a, $00
;    ret z
;    cp a, $01
;    ret z
;    cp a, $02
;    ret z
;    cp a, $04
;    ret z
;    cp a, $05
;    ret z
;    cp a, $06
;    ret z
;    cp a, $07
;    ret

;; ANCHOR: check-for-brick
;; Checks if a brick was collided with and breaks it if possible.
;; @param hl: address of tile.
;CheckAndHandleBrick:
;    ld a, [hl]
;    cp a, BRICK_LEFT
;    jr nz, CheckAndHandleBrickRight
;    ; Break a brick from the left side.
;    ld [hl], BLANK_TILE
;    inc hl
;    ld [hl], BLANK_TILE
;CheckAndHandleBrickRight:
;    cp a, BRICK_RIGHT
;    ret nz
;    ; Break a brick from the right side.
;    ld [hl], BLANK_TILE
;    dec hl
;    ld [hl], BLANK_TILE
;    ret
;; ANCHOR_END: check-for-brick

fn Input
    pass
;  ; Poll half the controller
;  ld a, P1F_GET_BTN
;  call .onenibble
;  ld b, a ; B7-4 = 1; B3-0 = unpressed buttons

;  ; Poll the other half
;  ld a, P1F_GET_DPAD
;  call .onenibble
;  swap a ; A3-0 = unpressed directions; A7-4 = 1
;  xor a, b ; A = pressed buttons + directions
;  ld b, a ; B = pressed buttons + directions

;  ; And release the controller
;  ld a, P1F_GET_NONE
;  ldh [rP1], a

;  ; Combine with previous wCurKeys to make wNewKeys
;  ld a, [wCurKeys]
;  xor a, b ; A = keys that changed state
;  and a, b ; A = keys that changed to pressed
;  ld [wNewKeys], a
;  ld a, b
;  ld [wCurKeys], a
;  ret

;.onenibble
;  ldh [rP1], a ; switch the key matrix
;  call .knownret ; burn 10 cycles calling a known ret
;  ldh a, [rP1] ; ignore value while waiting for the key matrix to settle
;  ldh a, [rP1]
;  ldh a, [rP1] ; this read counts
;  or a, $F0 ; A7-4 = 1; A3-0 = unpressed keys
;.knownret
;  ret

;; Copy bytes from one area to another.
;; @param de: Source
;; @param hl: Destination
;; @param bc: Length
;Memcopy:
;    ld a, [de]
;    ld [hli], a
;    inc de
;    dec bc
;    ld a, b
;    or a, c
;    jp nz, Memcopy
;    ret
