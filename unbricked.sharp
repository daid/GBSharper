; https://raw.githubusercontent.com/gbdev/gb-asm-tutorial/master/unbricked/bricks/main.asm
; INCLUDE "hardware.inc"
reg rP1 = 0xFF00
reg rLCDC = 0xFF40
reg rLY = 0xFF44
reg rBGP = 0xFF47
reg rOBP0 = 0xFF48
reg _OAMRAM0 = 0xFE00
reg _OAMRAM1 = 0xFE01
reg _OAMRAM2 = 0xFE02
reg _OAMRAM3 = 0xFE03
reg _OAMRAM4 = 0xFE04
reg _OAMRAM5 = 0xFE05
reg _OAMRAM6 = 0xFE06
reg _OAMRAM7 = 0xFE07


const BRICK_LEFT = 0x05
const BRICK_RIGHT = 0x06
const BLANK_TILE = 0x08

var frameCounter = 0

var curKeys = 0
var newKeys = 0

var ballMomentumX = 0
var ballMomentumY = 0

fn main
    while rLY < 144
        pass
    rLCDC = 0

    ; Copy the tile data
;    ld de, Tiles
;    ld hl, $9000
;    ld bc, TilesEnd - Tiles
;    call Memcopy

    ; Copy the tilemap
;    ld de, Tilemap
;    ld hl, $9800
;    ld bc, TilemapEnd - Tilemap
;    call Memcopy

    ; Copy the paddle tile
;    ld de, Paddle
;    ld hl, $8000
;    ld bc, PaddleEnd - Paddle
;    call Memcopy

    ; Copy the ball tile
;    ld de, Ball
;    ld hl, $8010
;    ld bc, BallEnd - Ball
;    call Memcopy

;    xor a, a
;    ld b, 160
;    ld hl, _OAMRAM
;ClearOam:
;    ld [hli], a
;    dec b
;    jp nz, ClearOam

    ; Initialize the paddle sprite in OAM
    _OAMRAM0 = 128 + 16
    _OAMRAM1 = 16 + 8
    _OAMRAM2 = 0
    _OAMRAM3 = 0
    ; Now initialize the ball sprite
    _OAMRAM4 = 100 + 16
    _OAMRAM5 = 32 + 8
    _OAMRAM6 = 1
    _OAMRAM7 = 0

    ; The ball starts out going up and to the right
    ballMomentumX = 1
    ballMomentumY = -1

    ; Turn the LCD on
    rLCDC = 0x83 ; LCDCF_ON | LCDCF_BGON | LCDCF_OBJON

    ; During the first (blank) frame, initialize display registers
    rBGP = 0b11100100
    rOBP0 = 0b11100100

    ; Initialize global variables
    frameCounter = 0
    curKeys = 0
    newKeys = 0

    while 1
        while rLY > 143
            pass
        while rLY < 144
            pass

        ; Add the ball's momentum to its position in OAM.
        _OAMRAM5 = _OAMRAM5 + ballMomentumX
        _OAMRAM4 = _OAMRAM4 + ballMomentumY

    ; ANCHOR: updated-bounce
    ;BounceOnTop:
    ;    ; Remember to offset the OAM position!
    ;    ; (8, 16) in OAM coordinates is (0, 0) on the screen.
    ;    ld a, [_OAMRAM + 4]
    ;    sub a, 16 + 1
    ;    ld c, a
    ;    ld a, [_OAMRAM + 5]
    ;    sub a, 8
    ;    ld b, a
    ;    call GetTileByPixel ; Returns tile address in hl
    ;    ld a, [hl]
    ;    call IsWallTile
    ;    jp nz, BounceOnRight
    ;    call CheckAndHandleBrick
    ;    ld a, 1
    ;    ld [wBallMomentumY], a
    
    ;BounceOnRight:
    ;    ld a, [_OAMRAM + 4]
    ;    sub a, 16
    ;    ld c, a
    ;    ld a, [_OAMRAM + 5]
    ;    sub a, 8 - 1
    ;    ld b, a
    ;    call GetTileByPixel
    ;    ld a, [hl]
    ;    call IsWallTile
    ;    jp nz, BounceOnLeft
    ;    call CheckAndHandleBrick
    ;    ld a, -1
    ;    ld [wBallMomentumX], a
    ;
    ;BounceOnLeft:
    ;    ld a, [_OAMRAM + 4]
    ;    sub a, 16
    ;    ld c, a
    ;    ld a, [_OAMRAM + 5]
    ;    sub a, 8 + 1
    ;    ld b, a
    ;    call GetTileByPixel
    ;    ld a, [hl]
    ;    call IsWallTile
    ;    jp nz, BounceOnBottom
    ;    call CheckAndHandleBrick
    ;    ld a, 1
    ;    ld [wBallMomentumX], a

    ;BounceOnBottom:
    ;    ld a, [_OAMRAM + 4]
    ;    sub a, 16 - 1
    ;    ld c, a
    ;    ld a, [_OAMRAM + 5]
    ;    sub a, 8
    ;    ld b, a
    ;    call GetTileByPixel
    ;    ld a, [hl]
    ;    call IsWallTile
    ;    jp nz, BounceDone
    ;    call CheckAndHandleBrick
    ;    ld a, -1
    ;    ld [wBallMomentumY], a
    ;BounceDone:
    ; ANCHOR_END: updated-bounce

        ; First, check if the ball is low enough to bounce off the paddle.
        if _OAMRAM0 == _OAMRAM4
            ; Now let's compare the X positions of the objects to see if they're touching.
            if _OAMRAM5 < _OAMRAM1 + 16
                if _OAMRAM5 > _OAMRAM1 - 8
                    ballMomentumY = -1

        ; Check the current keys every frame and move left or right.
        input()

        if curKeys & 0x20
            if _OAMRAM1 != 15
                _OAMRAM1 = _OAMRAM1 - 1
        if curKeys & 0x10
            if _OAMRAM1 != 105
                _OAMRAM1 = _OAMRAM1 + 1

;; Convert a pixel position to a tilemap address
;; hl = $9800 + X + Y * 32
;; @param b: X
;; @param c: Y
;; @return hl: tile address
;GetTileByPixel:
;    ; First, we need to divide by 8 to convert a pixel position to a tile position.
;    ; After this we want to multiply the Y position by 32.
;    ; These operations effectively cancel out so we only need to mask the Y value.
;    ld a, c
;    and a, %11111000
;    ld l, a
;    ld h, 0
;    ; Now we have the position * 8 in hl
;    add hl, hl ; position * 16
;    add hl, hl ; position * 32
;    ; Just add the X position and offset to the tilemap, and we're done.
;    ld a, b
;    srl a ; a / 2
;    srl a ; a / 4
;    srl a ; a / 8
;    add a, l
;    ld l, a
;    adc a, h
;    sub a, l
;    ld h, a
;    ld bc, $9800
;    add hl, bc
;    ret

;; @param a: tile ID
;; @return z: set if a is a wall.
fn isWallTile tile > u8
    if tile < 8
        return 1
    return 0

;; ANCHOR: check-for-brick
;; Checks if a brick was collided with and breaks it if possible.
;; @param hl: address of tile.
;CheckAndHandleBrick:
;    ld a, [hl]
;    cp a, BRICK_LEFT
;    jr nz, CheckAndHandleBrickRight
;    ; Break a brick from the left side.
;    ld [hl], BLANK_TILE
;    inc hl
;    ld [hl], BLANK_TILE
;CheckAndHandleBrickRight:
;    cp a, BRICK_RIGHT
;    ret nz
;    ; Break a brick from the right side.
;    ld [hl], BLANK_TILE
;    dec hl
;    ld [hl], BLANK_TILE
;    ret
;; ANCHOR_END: check-for-brick

fn input
    rP1 = 0x10
    var keys = rP1 | 0xF0
    rP1 = 0x20
    keys = -(keys & ((rP1 << 4) | 0x0F))
    newKeys = (curKeys ^ keys) & keys
    curKeys = keys
